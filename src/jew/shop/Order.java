package jew.shop;

//Есть магазин, сейчас он закрыт. Со вчерашнего дня у него осталось 4 заказа.
// Директор магазина еврей и он хочет сначала обрабатывать самые дорогие заказы.
// Как магазин откроется, в него сразу же пойдут заказы (симуляцию заказов можно сделать через массив, предворительно подготовив их).
// Как только приходит новый заказ, мы сразу берем самый дорогой и обрабатываем его, например доставляем.
// В конце дня у магазина должно остаться 4 заказа, логично, что они будут самыми дешевыми.
// тут нужно использовать PriorityQueue, но немного иначе
//        Заказ пусть будет такой class Order {int id; int price;}
// Просто поймешь, почему это очередь и почему она приоритетная. Очереди очень важны при моделировании разной ерунды

//Ну пусть просто печатает обработал заказ такой-то, Обработал заказ такой-то и конце пусть просто выведет заказы которые остались
// не удаляя их из очереди)

//нужно положить сначала туда 4 заказа, типа вчерашних
// потом создать массив из сегодняшних, брать с максимальной ценой и его обрабатывать
//в конце должно остатья 4 заказа, так как только 5 ты смогла обработать

public class Order implements Comparable<Order> {

    private int id;
    private int price;

    public Order(int id, int price) {
        this.id = id;
        this.price = price;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    @Override
    public int compareTo(Order o) {
        return  o.getPrice() - this.price;
    }

    @Override
    public String toString() {
        return "Order{" +
                "id=" + id +
                ", price=" + price +
                '}';
    }
}

